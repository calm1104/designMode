### 创建型模式（Creational Patterns）：组件的创建
###### 关注点为："怎样创建出对象？"，将对象的创建与使用分离。
###### 作用：降低系统耦合度。使用者无需关注对象的创建细节
- **工厂方法模式（FactoryMethod）:就是在函数中创建一个对象，给对象添加属性及其属性值或属性方法然后在将这个对象用return返回出来（return 是关键**
- **抽象工厂模式(AbstractFactory)：抽象工厂模式用于生成产品族的工厂，所生成的对象是有关联的。如果抽象工厂退化成生成的对象无关联则成为工厂函数模式**
- **建造/生成器模式(Builder)：对象的创建由一个建造者来完成，更关注对象的细节，不同于工厂模式不在乎细节。向工厂要一个对象与创建一个对象中的细节的区别。**
- 原型模式（Prototype）：对象的创建由原来对象克隆完成
- **单例模式(Singleton)：对象始终在系统中只有一个实例，懒汉模式：我很懒不到用的时候不初始化，饿汉模式：我很饿，上来就要面包吃。**

### 结构型模式（Structural Patterns）：组件的定义
###### 关注点："怎样组合对象"，使用关联关系来替代继承关系（组合）
- **适配器模式(Adapter)：两个不兼容接口之间适配的桥梁，从用户的角度看不到被适配者，是解耦的。**
- **桥接模式(Bridge)：桥接模式即将抽象部分与它的实现部分分离开来，使他们都可以独立变化，桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度**
- **组合模式(Composite)：相似对象进行组合，行程树形结构**
- **装饰模式(Decorator)：向一个现有的对象添加新的功能，同时又不改变其结构(类似递归调用)**
- 外观模式(Facade)：向现有的系统添加一个接口，客户端访问此接口来隐藏系统的复杂性
- 享元模式(Flyweight)：尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象
- **代理模式(Proxy)：代理接收客户端的请求并进行一些处理 （访问控制和缓存等）， 然后再将请求传递给服务对象。（一个类代表另一个类的功能）**

### 行为模式（Behavioral Patterns）：组件的服役
- **责任链模式(Chain of Responsibility)：该模式允许多个对象来对请求进行处理（医院看病流程）**
- 命令模式(Command): 它可将请求或简单操作转换为一个对象。此类转换让你能够延迟进行或远程执行请求， 还可将其放入队列中。注意我们是如何将相同请求封装进多个请求者的。创建独立命令对象的优势在于可将 UI 逻辑与底层业务逻辑解耦。 这样就无需为每个请求者开发不同的处理者了。 命令对象中包含执行所需的全部信息， 所以也可用于延迟执行。
- **迭代器模式(Lterator)： 让你能在不暴露复杂数据结构内部细节的情况下遍历其中所有的元素，主要思想是将集合背后的迭代逻辑提取至不同的、 名为迭代器的对象中**
- 中介者模式(Mediator):让程序组件通过特殊的中介者对象进行间接沟通， 达到减少组件之间依赖关系的目的
- 备忘录模式(Mediator):备忘录模式让我们可以保存对象状态的快照。 你可使用这些快照来将对象恢复到之前的状态。 这在需要在对象上实现撤销-重做操作时非常实用
- **观察者模式(Observer): 允许一个对象将其状态的改变通知其他对象,观察者模式提供了一种作用于任何实现了订阅者接口的对象的机制， 可对其事件进行订阅和取消订阅。**
- **状态模式(State):能在一个对象的内部状态变化时改变其行为，该模式将与状态相关的行为抽取到独立的状态类中， 让原对象将工作委派给这些类的实例， 而不是自行进行处理。(自动售货机)**
- **策略模式(Strategy):它将一组行为转换为对象， 并使其在原始上下文对象内部能够相互替换。原始对象被称为上下文， 它包含指向策略对象的引用并将执行行为的任务分派给策略对象。 为了改变上下文完成其工作的方式， 其他对象可以使用另一个对象来替换当前链接的策略对象。**
- **模板方法模式(Template Method):它在基类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。其中某个特定操作的步骤是相同的， 但实现方式却可能有所不同。 这正是适合考虑使用模板方法模式的情况(例子验证码功能)**
- 访问者模式(Visitor):允许你在不修改已有代码的情况下向已有类层次结构中增加新的行为，就是允许你在结构体中添加行为， 而又不会对结构体造成实际变更。 


##### 设计模式的精髓：对接口编程而不是对实现编程，优先使用对象组合而不是继承
##### 内网学习地址：https://km.woa.com/group/51889/articles/show/505075?kmref=dailymail_top&jumpfrom=daily_mail
##### 学习地址：https://refactoringguru.cn/design-patterns/go，https://km.woa.com/group/51889/articles/show/505075?kmref=dailymail_top&jumpfrom=daily_mail

##### 设计的7大原则：
1. 单一职责原则：每个类只负责自己的事情，而不是变成万能
2. 开闭原则：扩展类而不是修改类
3. 赖倒置原则：高层模块不应该依赖于底层模块，二者都应该依赖其抽象，面向接口编程，而不是面向实现类（细节），
    -（理解：A.上层是使用者，下层是被使用者，这就导致的结果是上层依赖下层了，下层变动了，自然就会影响到上层了，导致系统不稳定，甚至是牵一发而动全身。那怎么减少依赖呢？就是上层和下层都去依赖另一个抽象，这个抽象比较稳定，整个就来说就比较稳定了）
    - 工厂模式通过让子类决定该创建的对象是什么，来达到将对象创建过程封装、弱化耦合的目的。这种设计模式利用了依赖倒置的原则。
4. 接口隔离原则：各个类建立自己的专用接口，而不是建立万能接口
5. 里氏替换原则：继承父类而不去改变父类 
6. 迪米特法则：无需直接交互的两个类，如果需要交互，使用中间者（不能过度使用迪米特法则，会产生大量中介类，使模块之间的通信效率降低）
7. 合成复用原则：优先组合其次继承，组合就是把要引用的对象当成属性，继承就是把要引用的对象的方法直接拿过来叫继承。
设计模式的精髓在于对面向对象编程特性之一——多态的灵活应用，而多态正是面向对象编程的本质所在


    
    
            